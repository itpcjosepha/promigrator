<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Three.js Glassy Glow</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: radial-gradient(circle at top, #1f2933 0, #020617 55%, #000 100%);
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }

      #app {
        width: 100vw;
        height: 100vh;
      }

      .overlay {
        position: fixed;
        left: 1.5rem;
        bottom: 1.5rem;
        color: #e5e7eb;
        font-size: 0.85rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        opacity: 0.7;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div class="overlay">Drag to orbit â€¢ Scroll to zoom</div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js";

      const container = document.getElementById("app");

      // Scene
      const scene = new THREE.Scene();

      // Camera
      const camera = new THREE.PerspectiveCamera(
        55,
        container.clientWidth / container.clientHeight,
        0.1,
        100
      );
      camera.position.set(0, 1.5, 6);

      // Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputEncoding = THREE.sRGBEncoding;
      container.appendChild(renderer.domElement);

      // Orbit controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.7;
      controls.zoomSpeed = 0.7;
      controls.minDistance = 3;
      controls.maxDistance = 12;
      controls.target.set(0, 0.5, 0);
      controls.update();

      // Floor
      const floorGeometry = new THREE.CircleGeometry(8, 64);
      const floorMaterial = new THREE.MeshStandardMaterial({
        color: 0x020617,
        metalness: 0.6,
        roughness: 0.3,
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -1.25;
      scene.add(floor);

      // Glassy-ish outer sphere (transparent, reflective-ish)
      const glassGeometry = new THREE.SphereGeometry(1.2, 64, 64);
      const glassMaterial = new THREE.MeshStandardMaterial({
        color: 0x38bdf8,
        metalness: 0.7,
        roughness: 0.1,
        transparent: true,
        opacity: 0.35,
      });
      const glassSphere = new THREE.Mesh(glassGeometry, glassMaterial);
      glassSphere.position.y = 0.5;
      scene.add(glassSphere);

      // Glowing core
      const coreGeometry = new THREE.SphereGeometry(0.45, 48, 48);
      const coreMaterial = new THREE.MeshStandardMaterial({
        color: 0x22c55e,
        emissive: 0x22c55e,
        emissiveIntensity: 3.0,
        metalness: 0.2,
        roughness: 0.3,
      });
      const core = new THREE.Mesh(coreGeometry, coreMaterial);
      core.position.copy(glassSphere.position);
      scene.add(core);

      // Neon rings around the sphere
      const ringGroup = new THREE.Group();
      scene.add(ringGroup);

      const ringColors = ["#38bdf8", "#a855f7", "#f97316"];

      ringColors.forEach((hex, index) => {
        const ringGeo = new THREE.TorusGeometry(1.7 + index * 0.25, 0.05, 32, 200);
        const ringMat = new THREE.MeshStandardMaterial({
          color: new THREE.Color(hex),
          emissive: new THREE.Color(hex),
          emissiveIntensity: 2.2,
          metalness: 0.8,
          roughness: 0.15,
        });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = (index * Math.PI) / 6 + 0.6;
        ring.rotation.y = (index * Math.PI) / 8;
        ring.position.y = glassSphere.position.y;
        ringGroup.add(ring);
      });

      // Floating particles
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = 400;
      const positions = new Float32Array(particlesCount * 3);

      for (let i = 0; i < particlesCount * 3; i += 3) {
        const radius = 6 * Math.random() + 2;
        const angle = Math.random() * Math.PI * 2;
        const y = (Math.random() - 0.5) * 4;
        positions[i] = Math.cos(angle) * radius;
        positions[i + 1] = y;
        positions[i + 2] = Math.sin(angle) * radius;
      }

      particlesGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );

      const particlesMaterial = new THREE.PointsMaterial({
        size: 0.05,
        color: 0x60a5fa,
        transparent: true,
        opacity: 0.9,
      });

      const particles = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particles);

      // Lights
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
      mainLight.position.set(3, 5, 4);
      scene.add(mainLight);

      const fillLight = new THREE.PointLight(0x22c55e, 3.0, 12);
      fillLight.position.set(-2.5, 1.5, -1.5);
      scene.add(fillLight);

      const rimLight = new THREE.PointLight(0x38bdf8, 2.5, 10);
      rimLight.position.set(2.5, 2.0, 2.5);
      scene.add(rimLight);

      scene.add(new THREE.AmbientLight(0x404040, 0.7));

      // Resize handler
      window.addEventListener("resize", () => {
        const width = container.clientWidth;
        const height = container.clientHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      });

      // Animation loop
      const clock = new THREE.Clock();

      function animate() {
        const t = clock.getElapsedTime();

        // Subtle animations
        glassSphere.rotation.y = t * 0.15;
        core.rotation.y = -t * 0.4;
        core.position.y = 0.5 + Math.sin(t * 1.5) * 0.08;

        ringGroup.children.forEach((ring, index) => {
          ring.rotation.y += 0.002 + index * 0.0015;
          ring.rotation.x += 0.001 * (index + 1);
        });

        particles.rotation.y += 0.0008;
        particles.rotation.x = Math.sin(t * 0.05) * 0.1;

        fillLight.position.y = 1.5 + Math.sin(t * 1.2) * 0.3;
        rimLight.position.y = 2.0 + Math.cos(t * 0.9) * 0.25;

        controls.update();
        renderer.render(scene, camera);

        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
